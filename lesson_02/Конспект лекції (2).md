# Конспект лекції (2)

[Лекція Робота в git.pptx](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/%25D0%259B%25D0%25B5%25D0%25BA%25D1%2586%25D1%2596%25D1%258F_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0_%25D0%25B2_git.pptx)

## **Що таке система контроля версій**

[https://lh7-us.googleusercontent.com/YWg2dCYJST5YfMsySjKQwEfLts2DBkLUOeNQbt1220-nOH2Yhj0-_hutbPfUyGicNNNQ1FU14rjeyr6KLDSxQFhKmfXIZ6sPoLLPrsMD0rOGRi6ctlya3g742b3bS3S_Md3aPBZoVOjFyEHpybSg11g](https://lh7-us.googleusercontent.com/YWg2dCYJST5YfMsySjKQwEfLts2DBkLUOeNQbt1220-nOH2Yhj0-_hutbPfUyGicNNNQ1FU14rjeyr6KLDSxQFhKmfXIZ6sPoLLPrsMD0rOGRi6ctlya3g742b3bS3S_Md3aPBZoVOjFyEHpybSg11g)

Системи контроля версій (Version Control Systems, VCS) є незамінною частиною роботи розробників та команд, які працюють з програмним кодом та іншими файлами проекту. Вони надають зручний та ефективний спосіб відстеження змін у коді, спільної роботи над проектом, вирішення конфліктів та відновлення попередніх версій файлів. Ось декілька ключових аспектів систем контролю версій:

**1. Зберігання та Версіонування Коду:** Системи контролю версій зберігають всі версії коду, що дозволяє розробникам переглядати, порівнювати та відновлювати попередні версії коду. Це важливо для виявлення та усунення помилок, а також для розгляду розвитку проекту.

2. **Колективна Робота**: VCS дозволяють багатьом розробникам працювати над одним проектом одночасно, зберігаючи при цьому структурований та спільний доступ до коду. Кожен розробник може працювати власній гілці (branch) та потім об'єднувати свої зміни з основним кодом.

3. **Контроль Доступу**: В системах контролю версій можна налаштувати права доступу до проекту. Наприклад, деякі розробники можуть мати доступ на читання, а інші - на запис. Це важливо для забезпечення безпеки та конфіденційності проекту.

4. **Виявлення та Розв'язання Конфліктів**: Коли різні розробники вносять зміни в один файл, системи контролю версій допомагають виявити конфлікти та вирішити їх. Це важливо для підтримання цілісності коду та уникнення втрати даних.

5. **Історія та Аудит:** VCS зберігають докладну історію змін, включаючи авторів, дати та коментарі до кожної зміни. Це допомагає відстежити, коли, де та чому були зроблені зміни.

6. **Версіонування Документів та Даних**: ВCS не обмежуються лише кодом. Вони можуть бути використані для версіонування документів, зображень, конфігураційних файлів та інших даних проекту.

**Типи** систем контролю версій (СКВ):

- Локальні (Local).
- Централізовані (Centralized).
- Розподілені (Distributed).

**Локальні (Local)**

Локальні системи контролю версій (Local Version Control Systems, Local VCS) - це системи, які використовуються для керування версіями файлів на локальному комп'ютері або на окремій робочій станції. Вони призначені для ведення історії змін файлів та дозволяють розробникам відстежувати, порівнювати та відновлювати попередні версії файлів без потреби в підключенні до централізованого сервера чи мережі.

[https://lh7-us.googleusercontent.com/ATpm8nxlpLPcCiDsVkpfBXbEy93WbkRFWVz639wxtKrI4sygzsmHzCXDoHNHIJf9ShT90cz_OPnECNktYTXDL0AQct9XMRcSe1TV4mtkdZ8lCs5b0BREsg2LpCv8CM2msEC91hsZZDQK9fgBd5Nh3_A](https://lh7-us.googleusercontent.com/ATpm8nxlpLPcCiDsVkpfBXbEy93WbkRFWVz639wxtKrI4sygzsmHzCXDoHNHIJf9ShT90cz_OPnECNktYTXDL0AQct9XMRcSe1TV4mtkdZ8lCs5b0BREsg2LpCv8CM2msEC91hsZZDQK9fgBd5Nh3_A)

Основні риси та принципи роботи локальних систем контролю версій включають:

1. **Локальні репозиторії**: Кожен проект має свій власний локальний репозиторій, який зберігає версії файлів та історію змін. Цей репозиторій розташований на локальному комп'ютері розробника.

2. **Простота та Швидкість**: Локальні СКВ відомі своєю простотою та швидкістю, оскільки вони не вимагають підключення до мережі та централізованого сервера. Робота з ними є локальною операцією.

3. **Зручність для Особистого Використання**: Ці системи ідеально підходять для індивідуальних розробників, які працюють над проектами на своєму локальному комп'ютері та не потребують спільної роботи в команді.

4. **Обмежена Колаборація**: Локальні СКВ мають обмежені можливості для спільної роботи, оскільки вони не передбачають централізованого збереження та обміну даними між різними розробниками.

У більш складних та колаборативних проектах зазвичай використовують централізовані або розподілені системи контролю версій, що надають більше функціональності та можливостей для спільної роботи.

**Централізовані (Centralized)**

**Централізовані системи контролю версій** (Centralized Version Control Systems, Centralized VCS) - це системи, які використовують централізований сервер для збереження та керування версіями файлів та коду. У цих системах репозиторій, який містить історію змін та файли, знаходиться на центральному сервері, а розробники спільно працюють з ним, підключаючись до центрального сервера для здійснення операцій з контролю версій.

[https://lh7-us.googleusercontent.com/Q67t7Z815HJU9Yov-OrYnCPpqA5zJ-mPSW9_tWhXT-CbSRtRmr6qfhLEzy2FaWfHwRFDSAg6_H0Uf2FDDY8nj5EstOasXQ5XRtf75_gawo7Nv_8YZrnJnWL6rAu9jxmiymXMUCnLypof4sQTGRxi0Nw](https://lh7-us.googleusercontent.com/Q67t7Z815HJU9Yov-OrYnCPpqA5zJ-mPSW9_tWhXT-CbSRtRmr6qfhLEzy2FaWfHwRFDSAg6_H0Uf2FDDY8nj5EstOasXQ5XRtf75_gawo7Nv_8YZrnJnWL6rAu9jxmiymXMUCnLypof4sQTGRxi0Nw)

Основні риси та принципи роботи централізованих систем контролю версій включають:

1. **Централізований Репозиторій:** У цих системах репозиторій з історією змін та файлами знаходиться на центральному сервері. Всі розробники підключаються до центрального сервера для доступу до проекту.

2. **Клонування та Пулінг**: Розробники можуть клонувати (копіювати) репозиторій з сервера на свої робочі станції, робити зміни та публікувати (пулити) їх на сервер. Це вимагає доступу до сервера для керування версіями.

3. **Централізований Контроль Доступу**: Доступ до репозиторію контролюється централізовано, і адміністратор сервера може надавати права доступу розробникам.

4. **Зручність для Колаборації**: Централізовані СКВ забезпечують зручність для спільної роботи в команді, оскільки всі зміни відбуваються на центральному сервері і легко доступні всім розробникам.

5. **Історія та Версіонні Мітки**: Ці системи дозволяють вести докладну історію змін та встановлювати версійні мітки для зручного відстеження релізів.

6. **Потреба в Підключенні до Мережі**: Для роботи з централізованими СКВ розробникам потрібно мати доступ до центрального сервера через мережу.

Популярними централізованими системами контролю версій є Apache Subversion (SVN) та Microsoft Team Foundation Version Control (TFVC). Вони дозволяють ефективно керувати версіями файлів та коду в командах і організаціях, але вимагають централізованого сервера та мережевого доступу для спільної роботи.

**Розподілені (Distributed)**

Розподілені системи контролю версій (Distributed Version Control Systems, Distributed VCS) - це системи, в яких кожен розробник має свій власний клон (копію) повного репозиторію, включаючи історію змін та файли проекту. Ці розподілені копії репозиторію зазвичай знаходяться на локальних робочих станціях розробників. Кожен розробник може працювати зі своїм локальним клоном, здійснювати зміни, фіксувати їх і навіть обмінюватися з іншими розробниками безпосередньо. Пізніше ці зміни можуть бути об'єднані (злиті) в один спільний репозиторій.

[https://lh7-us.googleusercontent.com/d8Py0O7BNCbnHO-6nHvvacTqX4S0aHyzkzMVOw7EOu1H8jRgom2o7QY4uaAXJvmiN0FT8UBuIVLTNyw9ZHDfRyYp1GAI9g85WznoxizTAaPa69E0Tn1EAJtaCQ7-4kN0tdTOsytmPNOHWbZ2vMJo_D4](https://lh7-us.googleusercontent.com/d8Py0O7BNCbnHO-6nHvvacTqX4S0aHyzkzMVOw7EOu1H8jRgom2o7QY4uaAXJvmiN0FT8UBuIVLTNyw9ZHDfRyYp1GAI9g85WznoxizTAaPa69E0Tn1EAJtaCQ7-4kN0tdTOsytmPNOHWbZ2vMJo_D4)

Основні риси та принципи роботи розподілених систем контролю версій включають:

1. **Клонування та Робота Локально**: Розробники клонують весь репозиторій на свою локальну робочу станцію, де вони можуть працювати над проектом локально. Це дозволяє розробникам працювати безпосередньо навіть без підключення до мережі або центрального сервера.

2. **Локальні Гілки (Branches):** Розробники можуть створювати власні гілки в своєму локальному репозиторії для роботи над конкретними функціями чи завданнями.

3. **Злиття (Merge) та Конфлікти:** Розробники можуть злити свої зміни з іншими гілками, але це може призвести до конфліктів, які потрібно вирішити.

4. **Розподілені Операції**: В розподілених СКВ багато операцій відбуваються локально без підключення до центрального сервера, що зменшує завантаження мережі.

5. **Можливість Роботи Офлайн:** Розробники можуть продовжувати роботу зі своїми локальними копіями навіть у відсутності мережі.

6. **Гнучкість та Швидкість**: Розподілені СКВ надають гнучкість і швидкість роботи, оскільки багато операцій виконується локально.

Популярними розподіленими системами контролю версій є Git, Mercurial та Bazaar. Ці системи використовуються великими командами розробників для керування версіями коду та спільної роботи над проектами. Вони надають більше незалежності та можливостей для спільної роботи, порівняно з централізованими системами.

## **Конфігурація GIT**

Для налаштування Git і початку роботи з ним, вам необхідно виконати наступні основні кроки:

1. **Встановити Git**: Спочатку вам потрібно встановити Git на свою робочу станцію. Ви можете завантажити останню версію Git для вашої операційної системи з офіційного сайту Git (https://git-scm.com/). Інструкції щодо встановлення подані на веб-сайті.

2. **Конфігурація Імені та Email:** Після встановлення Git вам потрібно налаштувати своє ім'я та електронну адресу. Це інформація, яка буде включена в коміти, щоб ідентифікувати автора. Використовуйте наступні команди для налаштування:

`git config --global user.name "Ваше_Ім'я"`

`git config --global user.email "ваша@email.com"`

3. **Створення Репозиторію:** Створіть новий репозиторій для вашого проекту або склонуйте існуючий репозиторій з Git-сервера.

- Для створення нового локального репозиторію в папці проекту використовуйте:

`git init`

- Для клонування існуючого репозиторію використовуйте URL репозиторію:

`git clone URL_репозиторію`

4. **Робота з Файлами:** Додайте файли вашого проекту до репозиторію, щоб почати відстежувати їхні зміни. Використовуйте команду `git add` для додавання файлів у стан для коміту:

`git add назва_файлу`

5. **Коміт Змін**: Зафіксуйте зміни у репозиторії за допомогою команди `git commit`:

`git commit -m "Ваш коментар до змін"`

6. **Синхронізація з Віддаленим Репозиторієм:** Якщо ви працюєте в команді, спільно над проектом, то важливо синхронізувати ваш репозиторій з віддаленим сервером (наприклад, GitHub або GitLab). Використовуйте `git push` для відправлення змін на сервер і `git pull` для отримання оновлень.

`git push origin master`

Ці кроки є основними для налаштування та роботи з Git. Вони допоможуть вам почати використовувати систему контролю версій для керування вашим проектом та спільної роботи з іншими розробниками.

**Нижче буде розписано більш детально як працюють та що означають всі ці команди.**

## **Основні команди GIT**

Давайте розберемо основні стани які можуть бути в гіт. Стани "**Committed**," "**Modified**," і "**Staged**" є ключовими поняттями в системі контролю версій Git і відображають стани файлів у репозиторії. Ось як вони працюють:

1. **Committed (Закомічено):**

- Цей стан відображається в локальному репозиторії Git.

- Файли в стані "committed" означають, що їхні останні зміни були збережені в репозиторії, і вони зафіксовані в певному коміті.

- Коміти представляють собою знімки (snapshot) всього проекту на певний момент у часі. Вони зберігають історію проекту та іншу важливу інформацію.

2. **Modified (Змінено):**

- Файли в стані "modified" означають, що ви внесли зміни до файлу в робочому каталозі (working directory), але їх ще не було збережено в репозиторії.

- Git відстежує зміни у файлах та розрізняє їх від версій, які були закомічені.

- Файли у стані "modified" потребують подальшої дії, такої як додавання їх до індексу (staging) та подальший коміт.

3. **Staged (Підготовлено до коміту):**

- Файли в стані "staged" означають, що ви вибрали їх для включення до наступного коміту.

- Цей стан відображається в індексі (index) або "staging area." Файли у стані "staged" вже були додані до індексу за допомогою команди `git add`.

- Коли ви робите коміт, Git використовує файли зі стану "staged," і вони включаються до нового коміту.

Розуміння цих трьох станів допомагає вам керувати змінами в проекті та використовувати Git для ефективного ведення історії вашого коду.

[https://lh7-us.googleusercontent.com/gXfVlOnaweji95zTaIE0VeADvuhX348Y43h2SP3CQ1rnQfTf-ZqRHpOiPZ3lSuitetX1LJIFZwvJdyPK7VSvEWi3KyoY0BM4oiYH_rRUsrakaRex1ia24hj0jovfzY6O6yEWlDnKYzsCvY4tkqskKzM](https://lh7-us.googleusercontent.com/gXfVlOnaweji95zTaIE0VeADvuhX348Y43h2SP3CQ1rnQfTf-ZqRHpOiPZ3lSuitetX1LJIFZwvJdyPK7VSvEWi3KyoY0BM4oiYH_rRUsrakaRex1ia24hj0jovfzY6O6yEWlDnKYzsCvY4tkqskKzM)

**Локальний репозиторій:**

- Локальний репозиторій - це репозиторій, який знаходиться на вашому комп'ютері. Він містить всі файли, історію змін та гілки пов'язані з конкретним проектом.
- Локальний репозиторій використовується для збереження копії проекту на вашому комп'ютері та для виконання операцій керування версіями (наприклад, фіксація змін, створення гілок, об'єднання змін тощо) без підключення до централізованого сервера.
- Робота в локальному репозиторії дає можливість розробникам працювати над кодом, навіть коли вони не підключені до Інтернету або до централізованого сервера.

**Віддалений репозиторій:**

- Віддалений репозиторій - це репозиторій, який розташований на віддаленому сервері або в хмарному сервісі. Він служить для збереження централізованої копії проекту та обміну кодом між різними розробниками.
- Віддалений репозиторій може бути доступний через мережу (зазвичай через протоколи, такі як HTTPS або SSH) і дозволяє декільком розробникам спільно працювати над проектом, синхронізувати зміни, об'єднувати гілки тощо.
- Популярними веб-сервісами для збереження віддалених репозиторіїв є GitHub, GitLab, Bitbucket та інші.

**Найпопулярніші віддалені репозитарії:**

- [https://bitbucket.org/](https://bitbucket.org/)
- [https://github.com/](https://github.com/)
- [https://about.gitlab.com/](https://about.gitlab.com/)

**GIT INIT**

1. Перейдіть до директорії вашого проекту за допомогою команди `cd`, якщо ви ще не знаходитесь в потрібному місці.

2. Виконайте команду

`git init`

Це створить каталог `.git` в поточній директорії, де Git буде зберігати всю інформацію про репозиторій, включаючи історію комітів, гілки та інші дані.

3. Після виконання `git init`, ваш проект стане Git-репозиторієм, і Git буде відстежувати зміни в файлах цієї директорії.

**GIT STATUS**

Команда `git status` використовується для перевірки статусу вашого локального Git-репозиторію. Вона надає інформацію про стан файлів в вашому робочому каталозі (робоча директорія), індексі (staging area) та поточному гілці (branch).

Ось як вона працює:

1. Запустіть командний рядок або термінал у директорії, де розташований ваш Git-репозиторій.

2. Виконайте команду `git status`:

`git status`

3. Git поверне інформацію про поточний статус вашого репозиторію. Інформація може включати такі розділи:

- Зміни, які не додані до індексу (Changes not staged for commit): Цей розділ показує файли, які були змінені в робочому каталозі, але ще не були додані до індексу. Ви побачите назви файлів та зміни, які були внесені в цих файлах.

- Зміни, які додані до індексу (Changes to be committed): Цей розділ показує файли, які були додані до індексу та готові для коміту. Ви побачите назви файлів, які були додані до індексу.

У системі контролю версій Git файли можуть перебувати в різних статусах, що вказують на їх поточний стан у репозиторії. Основні статуси для файлів в Git включають:

[https://lh7-us.googleusercontent.com/np27W29gctQxvPT18BpI2pCCULdl4WBP-IG7gL6RslFnpoRfn9qoYERpGgzqW8783snhaD90Hl_vUmGlhALF4reB3LX3JK1b3GpeK91GrDNYY7-f3Eou3RuJ2h-qibnRPh__JJr4gATThhWvzs7cAUQ](https://lh7-us.googleusercontent.com/np27W29gctQxvPT18BpI2pCCULdl4WBP-IG7gL6RslFnpoRfn9qoYERpGgzqW8783snhaD90Hl_vUmGlhALF4reB3LX3JK1b3GpeK91GrDNYY7-f3Eou3RuJ2h-qibnRPh__JJr4gATThhWvzs7cAUQ)

1. **Untracked (Невідстежуваний):**

- Файли, які не були додані до репозиторію та не відстежуються Git, мають статус "Untracked."

- Git не враховує зміни у таких файлах.

2. **Staged (Підготовлений до коміту):**

- Файли, які були додані до індексу (staging area), мають статус "Staged."

- Це означає, що вони готові до включення у наступний коміт.

3. **Modified (Змінений):**

- Файли, які були змінені в робочому каталозі, але не були додані до індексу, мають статус "Modified."

- Git враховує зміни у цих файлах, але вони не включені до наступного коміту.

**4. Committed (Закомічений):**

- Файли, які були додані до репозиторію і закомічені, мають статус "Committed."

- Ці файли збережені у попередніх комітах та включені в історію репозиторію.

**GIT ADD**

Команда `git add` використовується для додавання файлів і змін до індексу Git (іноді його називають "staging area"), щоб підготувати їх до наступного коміту. Ця команда дозволяє вам визначити, які файли та зміни будуть включені в наступний коміт. Ось як вона працює:

1. Для додавання конкретного файлу до індексу виконайте команду `git add` і вкажіть шлях до файлу, який ви хочете додати. Наприклад:

`git add file.txt`

Ця команда додасть файл `file.txt` до індексу, підготовивши його до наступного коміту.

2. Якщо ви хочете додати всі змінені файли у поточному робочому каталозі до індексу, використовуйте команду `git add` без жодних аргументів:

`git add .`

Ця команда додасть всі змінені файли, які перебувають в робочому каталозі, до індексу.

**GIT COMMIT**

Команда `git commit` використовується для фіксації змін в вашому локальному репозиторії Git. Під час коміту ви зберігаєте зміни, які ви зробили в своєму робочому каталозі (збереженому в локальному репозиторії) в історії версій. Кожний коміт повинен мати повідомлення, яке коротко пояснює, які зміни він включає.

`git commit`

Параметри у коміт-повідомленнях:

- **m в команді git commit** використовується для безпосереднього введення коміт-повідомлення в командному рядку, без відкриття текстового редактора для створення багаторядкового повідомлення. Це корисно, коли вам потрібно зробити дрібний коміт і ввести короткий опис змін.

`git commit -m "Фікс помилки в змінній userCount"`

- **a в команді git commit** використовується для автоматичного включення всіх змінених файлів у коміт без потреби вказувати їх окремо. Використовуючи -a, ви призначаєте Git автоматично відстежувати всі зміни в ваших файлах і включати їх у коміт без необхідності вручну використовувати git add.

`git commit -a -m "Зроблено зміни у файлів A, B і C"`

- **-amend в команді git commit** дозволяє внести зміни до останнього коміту. Це корисно, коли ви хочете виправити помилки у вашому останньому коміті, додати більше змісту до нього або змінити його повідомлення.

`git commit --amend -m "Виправлено помилку і оновлено повідомлення"`

**GIT DIFF**

Команда `git diff` використовується для порівняння змін між двома різними комітами або між робочим деревом та індексним деревом в git. Вона дозволяє вам визначити, які рядки були додані, видалені або змінені між файлами. Ось як вона працює:

`git diff`

1. **git diff`** без будь-яких аргументів порівнює зміни між робочим деревом і індексним деревом. Ви побачите різницю між вмістом файлів, які ви змінили, і вмістом, який вже є в індексі.

2. **git diff <коміт>** дозволяє порівняти зміни між вашим робочим деревом та вказаним комітом. Ви побачите різницю між вмістом вашого робочого дерева та станом проекту в той момент, коли був зроблений вказаний коміт.

3. **git diff <перший коміт> <другий коміт>** дозволяє порівняти зміни між двома вказаними комітами. Ви побачите різницю між вмістом проекту на момент першого та другого комітів.

[https://lh7-us.googleusercontent.com/apxuVeLu6TOQfsvNPC8m7dR31lB4D3BAK8raZCLXLmItsB-umazgvJCMBeC-VJ10l7Tro1qrmQFgXKDy2Po8uzGVSQz7XIsfs4sgqYSQo5vnWP6U-ItYU5BJ-Wry_W-Ig0lWNxfw68RP17v-X_tpyzk](https://lh7-us.googleusercontent.com/apxuVeLu6TOQfsvNPC8m7dR31lB4D3BAK8raZCLXLmItsB-umazgvJCMBeC-VJ10l7Tro1qrmQFgXKDy2Po8uzGVSQz7XIsfs4sgqYSQo5vnWP6U-ItYU5BJ-Wry_W-Ig0lWNxfw68RP17v-X_tpyzk)

**GIT RESET**

Команда `git reset` використовується для скасування змін і переміщення головного вказівника (HEAD) та гілки на певний коміт або стан. Вона може використовуватися в різних режимах, в залежності від опцій, що вказуються. В основному, команда `git reset` використовується для відкату змін, які ще не були опубліковані.

[https://lh7-us.googleusercontent.com/LNrpc2WGUABexVAmEXN6NGqTHAmUx_S4qc7TAEaREwAavp2tlI-KmY6t5wPE7w17EObVQsm_wC_da7cXSgxr0DTmGkjlXKMYiAfBsuLLfw4KeFjS-1NS07oUQ8We2VVRPofrwcMuK0j8ob3t5AiOCKg](https://lh7-us.googleusercontent.com/LNrpc2WGUABexVAmEXN6NGqTHAmUx_S4qc7TAEaREwAavp2tlI-KmY6t5wPE7w17EObVQsm_wC_da7cXSgxr0DTmGkjlXKMYiAfBsuLLfw4KeFjS-1NS07oUQ8We2VVRPofrwcMuK0j8ob3t5AiOCKg)

Основні опції команди `git reset` включають:

1. **`--soft`**: Скасовує зміни, але залишає їх у робочому дереві та індексі. Головний вказівник переноситься на вказаний коміт. Використовується, коли ви хочете знову внести зміни та зробити новий коміт.

2. **`--mixed`** (за замовчуванням): Скасовує зміни та видаляє їх з індексу, але залишає в робочому дереві. Головний вказівник переноситься на вказаний коміт. Використовується, коли ви хочете переглянути зміни та знову індексувати їх перед новим комітом.

3. **`--hard`**: Скасовує зміни і повністю скидає індекс та робоче дерево до вказаного коміту. Будьте обережні, використовуючи цей режим, оскільки він безповоротно втрачає всі ваші незбережені зміни.

**Приклади використання команди `git reset`:**

- ``git reset --soft HEAD~1``: Скасовує останній коміт, але залишає зміни у робочому дереві та індексі.
- ``git reset --mixed HEAD~2``: Скасовує два останніх коміти, видаляючи їх з індексу, але залишаючи зміни в робочому дереві.
- ``git reset --hard abc123``: Повністю скасовує всі зміни до стану, вказаного коміту `abc123`.

**Зауважте**, що команда `git reset` впливає лише на ваш локальний репозиторій, і якщо ви вже опублікували коміти, то потрібно буде використовувати інші команди для виправлення цього у віддаленому репозиторії.

**GIT CLEAN**

Команда `git clean` використовується для видалення незкомічених (унтреканих) файлів і каталогів з робочого дерева. Це допомагає позбутися файлів, які не контролюються Git, і які можуть бути залишені після виконання попередніх операцій. Важливо пам'ятати, що команда `git clean` видаляє файли без можливості відновлення, тому користуйтесь нею обережно.

Основні параметри команди `git clean` включають:

1. **`-n` або `--dry-run`**: Цей параметр дозволяє перевірити, які файли будуть видалені, але не видаляє їх фактично. Ви отримаєте список файлів, які були б видалені виконанням команди, але вони залишаться недоторканими.

2. **`-f` або `--force`**: Цей параметр вказує Git видалити файли та каталоги з робочого дерева. Без цього параметра команда не виконує жодних дій.

3. **`-d`**: При використанні цього параметра, команда `git clean` також видаляє незкомічені каталоги. Без нього команда видаляє тільки файли.

4. **`-x`**: Цей параметр дозволяє видаляти незкомічені файли, навіть якщо вони перебувають під контролем `.gitignore` або `.git/info/exclude`.

**Приклади використання команди `git clean`:**

- ``git clean -n``: Вивести список файлів і каталогів, які будуть видалені, але не видаляти їх.
- ``git clean -f``: Видалити всі незкомічені файли з робочого дерева.
- ``git clean -f -d``: Видалити всі незкомічені файли і каталоги з робочого дерева.
- ``git clean -f -d -x**`**`: Видалити незкомічені файли та каталоги, включаючи ті, які ігноруються `.gitignore` або `.git/info/exclude`.

**GIT PUSH**

Команда `git push` використовується для відправки змін, зроблених в локальному репозиторії, на віддалений репозиторій, як правило, на веб-сервер, такий як GitHub або GitLab. Ця команда оновлює віддалений репозиторій новими змінами і завантажує їх туди. Це необхідно для спільної роботи з іншими розробниками та збереження збалансованої версії коду.

Основний синтаксис команди `git push` виглядає так:

`git push <remote> <branch>`

- `**remote**` вказує на віддалений репозиторій, до якого ви хочете відправити зміни. Найпоширеніший варіант - це `**origin**`, що вказує на віддалений репозиторій, з якого ви склонували ваш локальний репозиторій.
- **`branch`** вказує на гілку, яку ви хочете відправити на віддалений репозиторій.

Наприклад, команда `git push origin main` відправить зміни із локальної гілки `main` на віддалений репозиторій, позначений як `origin`.

Деякі основні аспекти роботи команди `git push`:

1. Зміни, які ви намагаєтеся відправити, повинні бути зафіксовані командою `git commit`.

2. Ви повинні мати дозвіл на запис в віддаленому репозиторії, тобто вам потрібно бути авторизованим на віддаленому сервері (наприклад, на GitHub).

3. Після виконання `git push`, ваші зміни будуть доступні іншим розробникам, які працюють з цим віддаленим репозиторієм.

4. Якщо ви працюєте з великою кількістю гілок, ви можете вказати іншу гілку, яку ви хочете відправити.

### **Git Hub**

GitHub - це веб-сервіс для зберігання, управління та спільної роботи над Git-репозиторіями. Git є розподіленою системою керування версіями, а GitHub надає інфраструктуру для зберігання та спільної роботи з репозиторіями Git у віддаленому режимі через Інтернет.

![25231.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/25231.png)

Основні функції та важливість GitHub включають:

1. **Зберігання репозиторіїв**: Ви можете зберігати свої Git-репозиторії на серверах GitHub. Це дозволяє вам зробити резервну копію коду та забезпечити доступ до нього з будь-якого пристрою з Інтернетом.
2. **Спільна робота над проектами**: GitHub спрощує спільну роботу над проектами. Багато розробників можуть спільно працювати над кодом, вносячи зміни та обговорюючи їх.
3. **Ведення історії змін**: GitHub веде докладну історію всіх змін у коді. Ви можете переглядати, порівнювати та відкочувати зміни.
4. **Проблеми та заявки на об'єднання**: GitHub надає інструменти для створення, відстеження та вирішення проблем в проекті, а також для надсилання заявок на об'єднання (Pull Requests), щоб об'єднати ваші зміни з основним кодом проекту.
5. **Інтеграція з іншими сервісами**: GitHub підтримує багато інших сервісів, таких як Travis CI для автоматизованого тестування, інструменти для розгортання на серверах та інші.
6. **Відкритий код та спільнота**: Багато важливих проектів на GitHub є відкритими для співпраці зі спільнотою розробників. GitHub допомагає великим і малим командам розробників взаємодіяти та вирішувати глобальні проблеми.

### Реєстрації та створення свого репозиторію

1. **Перейдіть на веб-сайт GitHub**: Відкрийте свій веб-браузер та перейдіть на сайт GitHub за адресою [https://github.com](https://github.com/).
2. **Реєстрація акаунта**: Якщо у вас ще немає облікового запису на GitHub, виберіть опцію "Sign up for GitHub" (Зареєструватися на GitHub). Заповніть необхідні поля, включаючи ім'я користувача, електронну пошту та пароль, а потім натисніть "Sign up for GitHub" (Зареєструватися на GitHub).
3. **Підтвердіть свою електронну пошту**: Після реєстрації вам надійде лист на вказану електронну пошту з проханням підтвердити свій обліковий запис. Клацніть по посиланню для підтвердження облікового запису.
4. **Створення репозиторію**:
    - Після підтвердження облікового запису увійдіть на GitHub, використовуючи свій логін та пароль.
    - У верхньому лівому куті сторінки натисніть New.
        
        ![Screenshot_162.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/Screenshot_162.png)
        
    - Або у верхньому правому куті натисніть на свою іконку, та виберіть розділ Your repositories і там так само натисніть кнопку New.
        
        ![Screenshot_163.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/Screenshot_163.png)
        
    - Заповніть інформацію про свій репозиторій: вкажіть назву, опис, оберіть вид доступності (приватний або загальнодоступний), інші параметри. Ви також можете ініціалізувати репозиторій з README файлом та вибрати ліцензію.
    - Після заповнення форми, натисніть "Create repository" (Створити репозиторій).

Тепер у вас є свій власний репозиторій на GitHub. Ви можете додавати код, завантажувати файли та спільно працювати з іншими розробниками.

## **Розгалуження (гілки) в Git**

### Основне поняття про розгалуження

Розгалуження (branching) в Git - це механізм, який дозволяє розробникам створювати окремі гілки (branches) у своєму репозиторії для роботи над певними функціональностями або завданнями, не впливаючи на основну (головну) гілку розробки. Розгалуження дозволяє різним розробникам чи розробницьким групам працювати над різними завданнями паралельно, а також виправляти помилки та додавати новий функціонал без впливу на основний код.

![GIT-Branchand-its-Operations.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/GIT-Branchand-its-Operations.png)

Основні переваги використання розгалужень в Git:

1. **Ізоляція роботи**: Кожна гілка представляє собою окремий контекст для роботи. Розробник може вносити зміни у своїй гілці, не впливаючи на інші гілки.
2. **Паралельний розвиток**: Розгалуження дозволяє одночасно працювати над кількома функціональностями чи завданнями без конфліктів між ними.
3. **Тестування інтеграції**: Розгалуження дозволяє проводити тестування нового коду окремо від головної гілки, зменшуючи ризики для основної розробки.
4. **Експерименти та новий функціонал**: Розгалуження може бути використане для створення окремих гілок для експериментів або реалізації нових функцій, які після тестування можуть бути об'єднані в основну гілку.

Приклади використання розгалужень в Git:

1. **Розробка нового функціоналу**: Розгалуження може бути створено для розробки нового функціоналу або фіксації певного завдання. Після завершення роботи над функціоналом, гілка може бути злита (merged) з основною гілкою.
2. **Виправлення помилок (bug fixing)**: Розгалуження може бути створено для виправлення певних помилок чи проблем в коді. Після виправлення помилок гілка знову зливається з основною гілкою.
3. **Тестування нових можливостей**: Розгалуження може бути створено для випробування нового функціоналу або можливостей, перш ніж вони будуть додані до основного коду.
4. **Спільна робота розробників**: Розгалуження дозволяє кільком розробникам працювати над різними завданнями у спільному репозиторії.

### Команда git remote

Команда `git remote` в Git використовується для управління списком віддалених репозиторіїв. Вона дозволяє додавати, переглядати, перейменовувати та видаляти віддалені репозиторії, з якими ви працюєте. Основні прапорці команди `git remote` включають:

`git remote -v` (або `-verbose`): Цей прапорець виводить список віддалених репозиторіїв і URL-адреси, за допомогою яких ви з ними співпрацюєте. Це дозволяє вам переглядати URL-адреси, пов'язані із віддаленими репозиторіями.

**Приклад використання:**

```
git remote -v
```

`git remote add <ім'я> <URL>`: Ця команда додає новий віддалений репозиторій з вказаним ім'ям і URL-адресою.

**Приклад використання:**

```
git remote add origin <https://github.com/user/repo.git>
```

`git remote remove <ім'я>`: Цей прапорець дозволяє вам видалити віддалений репозиторій з вказаним ім'ям.

**Приклад використання:**

```
git remote remove origin
```

`git remote rename <старе_ім'я> <нове_ім'я>`: Ця команда дозволяє перейменувати існуючий віддалений репозиторій зі старим іменем на нове ім'я.

Приклад використання:

```
git remote rename origin new-origin
```

`git remote set-url <ім'я> <новий_URL>`: Цей прапорець дозволяє вам змінити URL-адресу для існуючого віддаленого репозиторію з вказаним ім'ям.

Приклад використання:

```
git remote set-url origin <https://github.com/user/new-repo.git>
```

Команда `git remote` без жодних прапорців просто виводить список імен віддалених репозиторіїв, що були додані до вашого проекту.

Приклад використання:

```
git remote
```

Команда `git branch` в Git використовується для роботи з гілками (branches) в репозиторії. Основна робота команди полягає в створенні, перевірці, перейменуванні та видаленні гілок. Основні опції команди `git branch` включають:

### Команда git branch

`git branch`: Викликана без опцій, ця команда показує список всіх гілок в репозиторії. Поточна гілка виділена зірочкою.

Приклад виведення списку гілок:

```
* main
  feature-branch
  bugfix-branch
  development
```

`git branch <ім'я_гілки>`: Ця команда створює нову гілку з вказаним ім'ям.

Приклад створення нової гілки:

```
git branch new-feature-branch
```

`git branch -d <ім'я_гілки>`: Цей флаг використовується для видалення гілки з репозиторію. Якщо гілка має незлиті зміни, то команда не дозволить її видалити.

Приклад видалення гілки:

```
git branch -d bugfix-branch
```

`git branch -m <стара_гілка> <нова_гілка>`: Цей флаг дозволяє перейменувати гілку на нову.

Приклад перейменування гілки:

```
git branch -m old-branch new-branch
```

`git branch -a`: Цей флаг показує список всіх гілок у репозиторії, включаючи віддалені гілки, якщо такі є.

Приклад виведення списку всіх гілок, включаючи віддалені:

```
* main
  feature-branch
  remotes/origin/remote-branch
```

### Команда git merge

Команда **`git merge`** в Git використовується для об'єднання змін з іншої гілки в поточну гілку. Ця команда дозволяє інтегрувати зміни із вказаної гілки в поточну гілку розробки. Основний сценарій використання команди **`git merge`** передбачає такі дії:

1. Переключіться на гілку, в яку ви хочете об'єднати зміни. Наприклад, ви можете переключитися на головну гілку з розробної гілки, яку ви хочете об'єднати.
    
    ```
    shellCopy code
    git checkout main
    ```
    
2. Використайте команду **`git merge`**, щоб об'єднати зміни з іншої гілки. Зазвичай це виглядає наступним чином:
    
    ```
    shellCopy code
    git merge ім'я_гілки_з_змінами
    ```
    
    Наприклад, для об'єднання змін із гілки "feature-branch":
    
    ```
    shellCopy code
    git merge feature-branch
    ```
    
    Якщо об'єднання можливе без конфліктів, Git автоматично здійснює об'єднання. У цьому випадку у вас з'являється коміт, який об'єднує зміни із зазначеної гілки у поточну гілку.
    
3. Якщо в процесі об'єднання виникли конфлікти (коли одні й ті самі рядки в файлах були змінені в обох гілках, які об'єднуються), Git позначить конфліктні рядки у файлах, і вам потрібно буде вирішити ці конфлікти вручну. Після вирішення конфліктів вам потрібно зберегти зміни та додати файли до індексу за допомогою **`git add`**. Після цього ви можете створити коміт для об'єднання змін.
4. Після завершення об'єднання ви можете відправити оновлену гілку у віддалений репозиторій за допомогою команди **`git push`**.

У системі контролю версій Git конфлікт виникає, коли при спробі об'єднати (злити) зміни з різних гілок або гілки та головної гілки виникають конфлікти в коді. Це означає, що Git не може автоматично визначити, які зміни слід обрати, і вимагає втручання користувача для вирішення цих конфліктів. 

![image1_d21db326e6.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/image1_d21db326e6.png)

Конфлікти можуть бути різного типу, але основні класи конфліктів включають:

1. **Fast-Forward Merge (Швидке об'єднання)**:
    - **Опис**: Fast-forward merge виникає тоді, коли об'єднується гілка з історією комітів, яка може бути легко об'єднана без будь-яких конфліктів. Це стає можливим, коли немає інших змін на цій гілці, крім тих, які мають бути об'єднані.
    - **Приклад**: Якщо ви маєте гілку `feature` і гілку `main`, і гілка `feature` вже має всі зміни, які мають бути додані до `main`, то об'єднання буде швидким (fast-forward), і Git автоматично додасть всі коміти з гілки `feature` до гілки `main`.
2. **Recursive Merge (Рекурсивне об'єднання)**:
    - **Опис**: Рекурсивне об'єднання виникає, коли об'єднуються дві гілки з різними комітами у їх історії. В цьому випадку Git спробує знайти спільного предка (батька) для обох гілок та створить новий коміт, який включає зміни з обох гілок.
    - **Приклад**: Якщо гілка `feature` і гілка `main` мають різні коміти в своїй історії, Git спробує знайти спільного предка, створити новий коміт, який включає зміни з обох гілок та визначає його як нову версію гілки `main`.
3. **Merge Conflict (Конфлікт об'єднання)**:
    - **Опис**: Конфлікт об'єднання виникає, коли Git не може автоматично об'єднати зміни з двох гілок через суперечливості в коді. Це може статися, коли обидві гілки внесли зміни в одні й ті самі рядки файлів або коли одна гілка видалила файл, а інша гілка його змінила. Конфлікти потребують ручного втручання користувача для вирішення.
    - **Приклад**: Якщо гілка `feature` змінила деякі рядки в файлі, а гілка `main` також змінила ті ж рядки у тому ж файлі, об'єднання може спричинити конфлікт. Git відзначить ці конфліктні рядки та маркери, що показують області конфлікту, і користувач повинен вирішити, які зміни залишити та які видалити.

Кожен з цих видів об'єднань має свої власні особливості та використовується в різних ситуаціях в залежності від історії роботи з гілками в системі контролю версій Git.

Для вирішення конфліктів у Git, користувачу потрібно відредагувати файли, в яких виникли конфлікти, видалити маркери та визначити правильні зміни. Після цього файли позначаються як відредаговані та можуть бути додані до індексу, і користувач може створити коміт для вирішення конфлікту.

### Команда git pull

Команда `git pull` використовується для отримання (завантаження) змін з віддаленого репозиторію та об'єднання їх з поточною гілкою в локальному репозиторії. 

Основний синтаксис команди `git pull`:

```
git pull <remote> <branch>
```

- `<remote>`: Це вказує віддалений репозиторій, з якого ви хочете отримати зміни. Зазвичай це вказується як ім'я віддаленого, таке як `origin`.
- `<branch>`: Це вказує гілку віддаленого репозиторію, з якої ви хочете отримати зміни.

Приклади використання команди `git pull`:

1. Оновлення локальної гілки `main` з віддаленого репозиторію `origin`:
    
    ```bash
    git pull origin main
    ```
    
2. Оновлення локальної гілки `feature` з віддаленого репозиторію `myfork`:
    
    ```bash
    git pull myfork feature
    ```
    
3. Оновлення локальної гілки в поточному віддаленому репозиторії та гілки:
    
    ```bash
    git pull
    ```
    

Коли ви використовуєте `git pull`, Git автоматично виконує `git fetch`, отримує оновлення з віддаленого репозиторію, а потім спробує об'єднати ці зміни з поточною гілкою. Якщо об'єднання призводить до конфліктів, вам доведеться вирішити їх вручну.

### Команда git fetch

Команда `git fetch` використовується для отримання оновлень з віддаленого репозиторію, але не об'єднує зміни з вашим локальним робочим каталогом. Вона оновлює інформацію про гілки та віддалені посилання у вашому локальному репозиторії, але не змінює ваш робочий каталог або коміт.

Основний синтаксис команди `git fetch` виглядає наступним чином:

```bash
git fetch <remote>

```

де `<remote>` - це назва віддаленого репозиторію, з якого ви хочете отримати оновлення. Наприклад, якщо ваш віддалений репозиторій називається "origin", команда буде виглядати так:

```bash
git fetch origin

```

Команда `git fetch` завантажує оновлення з віддаленого репозиторію, але не вносить зміни до вашого робочого каталогу. Після того, як ви виконали `git fetch`, ви можете вирішити, чи хочете об'єднати ці оновлення з вашою локальною гілкою за допомогою команди `git merge` або `git rebase`.

Ця команда корисна в ситуаціях, коли ви хочете оновити інформацію про гілки та коміти, але не хочете автоматично об'єднувати зміни з вашим робочим каталогом.

### Різниця між git pull та git featch

Ключова різниця між `git pull` та `git fetch` полягає в тому, як вони оновлюють ваш локальний репозиторій віддаленого репозиторію.

![git-pull-vs-git-fetch.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/git-pull-vs-git-fetch.png)

1. **git fetch:**
    - `git fetch` завантажує оновлення з віддаленого репозиторію, але не об'єднує їх з вашим локальним робочим каталогом.
    - Ця команда лише оновлює інформацію про гілки та коміти у віддаленому репозиторії.
    - Після використання `git fetch`, ви можете вирішити, чи хочете об'єднати оновлення за допомогою `git merge` або `git rebase`.
    
    Приклад:
    
    ```bash
    git fetch origin
    
    ```
    
2. **git pull:**
    - `git pull` виконує дві операції одразу: виконує `git fetch` для отримання оновлень з віддаленого репозиторію та об'єднує їх автоматично з вашим локальним робочим каталогом.
    - Це означає, що він не лише завантажує оновлення, але і автоматично оновлює ваш робочий каталог, об'єднуючи зміни.
    
    Приклад:
    
    ```bash
    git pull origin master
    
    ```
    

Обираючи між `git fetch` та `git pull`, слід враховувати, що `git pull` може призводити до автоматичного об'єднання змін, що може бути необхідним у деяких випадках, але також може призводити до непередбачених конфліктів у ваших змінах. `git fetch` надає більше контролю, оскільки ви можете вирішити, коли і як об'єднати оновлення.

## **Просунуті команди**

### Команда git rebase

`git rebase` - це команда яка дозволяє переписувати історію комітів для полегшення злиття гілок або очищення історії від зайвих комітів. Основним принципом роботи `git rebase` є взяття послідовності комітів і застосування їх по одному на іншу гілку.

Основний синтаксис команди `git rebase` виглядає наступним чином:

```bash
git rebase <базова_гілка>

```

де `<базова_гілка>` - це гілка, на яку ви хочете накласти ваші коміти.

Додаткові префікси, такі як `--onto`, `--continue`, `--abort` і т. д., можуть використовуватися для додаткових опцій та дій під час ребейзу.

Наприклад, розглянемо деякі приклади:

1. **Простий ребейз:**
    
    ```bash
    git checkout feature-branch
    git rebase main
    
    ```
    
    Це виконає ребейз гілки `feature-branch` на останній коміт гілки `main`.
    
2. **Ребейз з вказанням коміту:**
    
    ```bash
    git rebase --onto new-base-branch old-base-branch feature-branch
    
    ```
    
    Це виконає ребейз гілки `feature-branch`, застосовуючи коміти на `new-base-branch`, якщо вони базуються на `old-base-branch`.
    
3. **Продовження після конфліктів:**
    
    ```bash
    git rebase --continue
    
    ```
    
    Після вирішення конфліктів під час ребейзу, ця команда дозволяє продовжити процес.
    
4. **Скасування ребейзу:**
    
    ```bash
    git rebase --abort
    
    ```
    
    Ця команда скасовує ребейз і повертає гілку до стану перед початком ребейзу.
    

`git rebase` - потужний інструмент, але слід використовувати його обережно, оскільки він змінює історію комітів. Важливо знати, що використання ребейзу може викликати конфлікти та впливати на інших користувачів, які спільно використовують репозиторій.

### Git merge vs git rebase

`git merge` та `git rebase` - це дві різні стратегії об'єднання змін в гіті, і кожна з них має свої переваги та використання в різних сценаріях. 

![Screenshot_53.png](%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%20%D0%BB%D0%B5%D0%BA%D1%86%D1%96%D1%96%CC%88%20(2)%2023b70d98ec0645b0b5a2d391f36d5f58/Screenshot_53.png)

**Ось їхні основні відмінності:**

### git merge:

1. **Створює новий коміт з об'єднаними змінами:**
    - `git merge` створює новий коміт, який об'єднує зміни з об'єднуваної гілки у вашу поточну гілку.
    - Історія залишається лінійною, і вона включає коміт з об'єднаною історією.
2. **Зберігає оригінальну історію:**
    - Оригінальні коміти з об'єднуваної гілки залишаються незмінними.
    - Це дозволяє зберігати контекст та історію роботи в окремих гілках.
3. **Зручний для спільної роботи:**
    - Використовується для об'єднання робочих гілок, особливо там, де важлива історія роботи в кожній гілці.

### git rebase:

1. **"Переписує" історію:**
    - `git rebase` бере всі ваші коміти з поточної гілки та "переписує" їх поверх комітів з об'єднуваної гілки.
    - Нові коміти з'являються в історії як нові коміти із зміненою базою.
2. **Лінійна історія:**
    - Зміни стаються лінійно, без створення додаткових комітів об'єднаної гілки.
    - Має наслідок чисту та просту історію.
3. **Може призводити до конфліктів:**
    - Іноді може виникнути необхідність вирішити конфлікти, особливо коли історії змінюють одні й ті самі рядки коду.
4. **Змінює ідентифікатори комітів:**
    - Оскільки коміти переписуються, вони отримують нові ідентифікатори.

Вибір між `git merge` та `git rebase` залежить від контексту вашої роботи, командних угод та ваших вподобань. Якщо ви хочете зберегти оригінальну історію кожної гілки, `git merge` може бути кращим вибором. Якщо ви шукаєте чисту та лінійну історію, `git rebase` може бути вигідним.

### Команда git cherry-pick

`git cherry-pick` - це команда в Git, яка дозволяє вам вибрати конкретний коміт з однієї гілки і застосувати його на іншу. Це корисно, коли вам потрібно перенести окремі зміни з однієї гілки на іншу.

Основний синтаксис команди `git cherry-pick` виглядає так:

```bash
git cherry-pick <коміт-хеш>

```

де `<коміт-хеш>` - це ідентифікатор цільового коміту, який ви хочете вибрати та застосувати.

**Основні префікси:**

1. **`-edit` або `e`:**
    - Дозволяє вам внести зміни до повідомлення коміту під час cherry-pick.
    
    ```bash
    git cherry-pick -e <коміт-хеш>
    
    ```
    
2. **`x`:**
    - Додає ідентифікатор оригінального коміту до повідомлення нового коміту.
    
    ```bash
    git cherry-pick -x <коміт-хеш>
    
    ```
    
3. **`-signoff` або `s`:**
    - Додає вашу підпис "Signed-off-by" до повідомлення нового коміту.
    
    ```bash
    git cherry-pick --signoff <коміт-хеш>
    
    ```
    

**Приклади:**

1. **Простий cherry-pick:**
    
    ```bash
    git cherry-pick abc123
    
    ```
    
    Це вибере коміт з хешем `abc123` та застосує його зміни на поточну гілку.
    
2. **Cherry-pick з редагуванням повідомлення коміту:**
    
    ```bash
    git cherry-pick -e abc123
    
    ```
    
    Це викличе редактор, дозволяючи вам внести зміни до повідомлення коміту перед застосуванням.
    
3. **Cherry-pick із збереженням оригінального ідентифікатора коміту:**
    
    ```bash
    git cherry-pick -x abc123
    
    ```
    
    Це додасть ідентифікатор оригінального коміту до повідомлення нового коміту.
    
4. **Cherry-pick з підписом "Signed-off-by":**
    
    ```bash
    git cherry-pick --signoff abc123
    
    ```
    
    Це додасть підпис "Signed-off-by" до повідомлення нового коміту.
    

`git cherry-pick` допомагає переносити конкретні зміни з однієї гілки на іншу, і використання префіксів дозволяє керувати деякими аспектами цього процесу, такими як редагування повідомлення чи додавання підпису до нового коміту.

### Команда git tag

`git tag` використовується для створення, перегляду та видалення тегів в Git. Теги використовуються для маркування конкретних комітів у вашому репозиторії, щоб вказати на важливі точки в історії проекту, такі як версії випуску.

Основний синтаксис команди `git tag`:

```bash
git tag <ім'я_тегу>

```

де `<ім'я_тегу>` - це ім'я, яке ви хочете присвоїти тегу поточному коміту. Тег буде вказувати на цей коміт.

**Основні префікси:**

1. **`a` або `-annotate`:**
    - Додає анотацію (повідомлення) до тегу та створює анотований тег.
    
    ```bash
    git tag -a v1.0 -m "Release version 1.0"
    
    ```
    
2. **`m` або `-message`:**
    - Вказує повідомлення для анотованого тегу.
    
    ```bash
    git tag -a v1.0 -m "Release version 1.0"
    
    ```
    
3. **`d` або `-delete`:**
    - Видаляє тег за його ім'ям.
    
    ```bash
    git tag -d v1.0
    
    ```
    

**Приклади:**

1. **Створення простого тегу:**
    
    ```bash
    git tag v1.0
    
    ```
    
    Це створить простий тег з ім'ям `v1.0`, який буде вказувати на поточний коміт.
    
2. **Створення анотованого тегу з повідомленням:**
    
    ```bash
    git tag -a v1.0 -m "Release version 1.0"
    
    ```
    
    Це створить анотований тег з ім'ям `v1.0` та повідомленням "Release version 1.0".
    
3. **Перегляд усіх тегів:**
    
    ```bash
    git tag
    
    ```
    
    Виведе список всіх тегів у репозиторії.
    
4. **Видалення тегу:**
    
    ```bash
    git tag -d v1.0
    
    ```
    
    Видалить тег з ім'ям `v1.0`.
    

Щоб поділитися тегами або завантажити їх до віддаленого репозиторію, вам слід використовувати команду `git push`:

```bash
git push origin <ім'я_тегу>

```

Наприклад:

```bash
git push origin v1.0

```

Це відправить тег з ім'ям `v1.0` до віддаленого репозиторію. Якщо ви маєте кілька тегів, ви можете скористатися командою:

```bash
git push origin --tags

```

Це відправить всі теги до віддаленого репозиторію.